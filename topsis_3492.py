# -*- coding: utf-8 -*-
"""Topsis_3492.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VnzgInc-dgrP0mIIrJxaiAqi8_7QCcQv
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Define models and criteria
data = {
    "Model": ["BERT", "RoBERTa", "DistilBERT", "XLNet", "T5"],
    "Accuracy": [0.89, 0.91, 0.86, 0.90, 0.88],  # Higher is better
    "F1-Score": [0.87, 0.89, 0.85, 0.88, 0.86],  # Higher is better
    "Inference Time (ms)": [120, 150, 80, 200, 180],  # Lower is better
    "Model Size (MB)": [400, 500, 250, 600, 550]  # Lower is better
}

# Convert to DataFrame
df = pd.DataFrame(data)
criteria = [1, 1, -1, -1]  # 1 for benefit, -1 for cost

# Normalize the decision matrix
matrix = df.iloc[:, 1:].values
def normalize(matrix):
    norm_matrix = matrix / np.sqrt((matrix**2).sum(axis=0))
    return norm_matrix
norm_matrix = normalize(matrix)

# Determine the ideal best & worst solutions
ideal_best = np.max(norm_matrix * (np.array(criteria) == 1), axis=0) + \
             np.min(norm_matrix * (np.array(criteria) == -1), axis=0)
ideal_worst = np.min(norm_matrix * (np.array(criteria) == 1), axis=0) + \
              np.max(norm_matrix * (np.array(criteria) == -1), axis=0)

# Calculate separation measures
distance_best = np.sqrt(((norm_matrix - ideal_best) ** 2).sum(axis=1))
distance_worst = np.sqrt(((norm_matrix - ideal_worst) ** 2).sum(axis=1))

# Step 5: Calculate TOPSIS scores & rank models
topsis_score = distance_worst / (distance_best + distance_worst)
df["TOPSIS Score"] = topsis_score
df["Rank"] = df["TOPSIS Score"].rank(ascending=False)

df = df.sort_values(by="Rank")
print(df)

# Visualization
plt.figure(figsize=(8, 5))
plt.barh(df['Model'], df['TOPSIS Score'], color='skyblue')
plt.xlabel("TOPSIS Score")
plt.title("Best Pre-Trained Model for Text Classification (TOPSIS)")
plt.gca().invert_yaxis()
plt.show()